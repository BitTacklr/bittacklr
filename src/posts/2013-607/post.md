---
original: https://seabites.wordpress.com/2013/02/24/a-role-to-play/
title: "A role to play"
slug: "a-role-to-play"
date: 2013-02-24
author: Yves Reynhout
publish: true
---
Every so often someone new arrives at the DDD/CQRS list (\*) and topics such as set based validation rear their head, resulting in near-endless threads of discussion and coming to a common understanding. A topic that isn't as often discussed is one of roles in the domain model and how that would work in combination with event sourcing. If you want to read up on roles, Mark Seemann has [some great posts on that topic](http://blog.ploeh.dk/2013/01/07/RoleHints.aspx "About roles") on his blog, albeit in a slightly different context. There's also this [video](http://www.infoq.com/presentations/Making-Roles-Explicit-Udi-Dahan "Making roles explicit video") by [Udi Dahan](http://www.udidahan.com/ "The software simplist") about making roles explicit, which is more akin to what I'll be touching upon here. Fanatics of whitepapers, might get their brain washed by papers like "[Role Interfaces](http://martinfowler.com/bliki/RoleInterface.html "Role interfaces")", "[The Role Object Pattern](http://hillside.net/plop/plop97/Proceedings/riehle.pdf "The Role Object Pattern")", "[Modeling Roles](http://objectdiscovery.com/solutions/publications/roles/index.html "Modeling Roles")" or "[Mock Roles, not Objects](http://jmock.org/oopsla2004.pdf "Mock Roles, not Objects")".

### Let's make it practical

Suppose I'm building a Realtor app that has a finite number of real estate property types (think apartment, villa, house, warehouse, etc...). I could model each type of property as a class/type (\*\*) putting specific behavior on each of them. I'd end up with Apartment, Villa, House and Warehouse as aggregate root entity types (and hence as aggregates). What if I had some common behavior that applies to all of them, where the calling code has a desire to be ignorant of the specific type, i.e. it is interested in the role that a property plays, not the specific type of property it represents. Let's call that role 'Property' for lack of inspiration. I could implement it using a base class, an interface or even a totally separate class as we'll see in a moment. The calling code could be about adding a set of properties to a listing: 

```csharp
 public class AddPropertiesToListingService { readonly IListingRepository \_listingRepository; readonly IPropertyRepository \_propertyRepository; public AddPropertiesToListingService(IListingRepository listingRepository, IPropertyRepository propertyRepository) { \_listingRepository = listingRepository; \_propertyRepository = propertyRepository; } public void AddPropertiesToListing(ListingId listingId, PropertyId\[\] propertyIds) { var listing = \_listingRepository.Get(listingId); var properties = propertyIds.Select(propertyId =&gt; \_propertyRepository.Get(propertyId)); listing.AddProperties(properties); } } 
```

 If this was modeled using either an interface or base class to denote the role, the repository code (\*\*\*) would look a bit like this: 

```csharp
 public interface IPropertyRepository { Property Get(Guid id); } public class PropertyRepository : IPropertyRepository { readonly IPropertyFactory \_factory; readonly IEventStreamReader \_reader; public PropertyRepository(IPropertyFactory factory, IEventStreamReader reader) { \_factory = factory; \_reader = reader; } public Property Get(Guid id) { var result = \_reader.Read(id); if(!result.HasValue) { throw new PropertyNotFoundException(id); } var root = \_factory.Create(result.Value); root.Initialize(result.Value.Events); return root; } } //This could also be a Func&lt;EventStream, Property&gt; public interface IPropertyFactory { Property Create(EventStream eventStream); } public class EventStreamAnalyzingPropertyFactory : IPropertyFactory { readonly Dictionary&lt;Type, Func&lt;Property&gt;&gt; \_propertyFactories; public EventStreamAnalyzingPropertyFactory() { \_propertyFactories = new Dictionary&lt;Type, Func&lt;Property&gt;&gt;(); //Assume that each of the aggregate root entities //has a static Factory method that creates a new instance. \_propertyFactories.Add(typeof(ApartmentRegistered), () =&gt; Apartment.Factory()); \_propertyFactories.Add(typeof(VillaRegistered), () =&gt; Villa.Factory()); \_propertyFactories.Add(typeof(HouseRegistered), () =&gt; House.Factory()); \_propertyFactories.Add(typeof(WarehouseRegistered), () =&gt; Warehouse.Factory()); //Remark: Yes, this is an OCP violation. } public Property Create(EventStream eventStream) { Func&lt;Property&gt; propertyFactory; if(!\_propertyFactories.TryGet(eventStream\[0\].GetType(), out propertyFactory)) throw new PropertyUnknownException(eventStream.Id); return propertyFactory(); } } public interface IEventStreamReader { Optional&lt;EventStream&gt; Read(Guid id); } public interface Optional&lt;T&gt; { bool HasValue { get; } T Value { get; } } public interface EventStream { Guid Id { get; } Int32 ExpectedVersion { get; } //In a real world implementation this would be streaming, //i.e. IEnumerable&lt;object&gt; object\[\] Events { get; } } public class PropertyNotFoundException : Exception { public PropertyNotFoundException(Guid id) { } } public class PropertyUnknownException : Exception { public PropertyUnknownException(Guid id) { } } //As an aside, Property could also be //turned into an interface to describe //the role behavior. public abstract class Property : AggregateRootEntity { /\* Common behavior can be put here \*/ } //Similar for the other property types. public class Villa : Property { public static readonly Func&lt;Villa&gt; Factory = () =&gt; new Villa(); Villa() { /\* ... \*/} /\* Specific behavior can be put here \*/ } 
```

 Notice how the factory is made responsible for analyzing the event stream and deciding which Property type to instantiate based on the type of the first event. It should be obvious that "the type of the first event" is just one of the ways you could come to decision of which Property type to instantiate. A slightly different scenario is one where you load the stream into a dedicated class, instead of relying on a base class or an interface to fulfill the role. 

```csharp
 public class Property { public static readonly Func&lt;Property&gt; Factory = () =&gt; new Property(); Property() { /\* Streams from each of the Property types can be loaded into this Role class \*/ Register&lt;ApartmentRegistered&gt;(When); Register&lt;VillaRegistered&gt;(When); Register&lt;HouseRegistered&gt;(When); Register&lt;WarehouseRegistered&gt;(When); /\* Notice how I haven't even brought up what you could do if these were polymorphic messages \*/ } /\* Common role behavior goes here \*/ } public class PropertyRepository : IPropertyRepository { readonly IEventStreamReader \_reader; public PropertyRepository(IEventStreamReader reader) { \_reader = reader; } public Property Get(Guid id) { var result = \_reader.Read(id); if(!result.HasValue) { throw new PropertyNotFoundException(id); } var root = Property.Factory(); root.Initialize(result.Value.Events); return root; } } 
```

 This is exactly why you shouldn't use the type name of an aggregate as a form of stream identification (at least if you want to support this kind of scenario). The repository will just load up the stream, being totally ignorant of what class was used to produce the events in the stream in the first place and happily feed it to the Property class. Another scenario where this technique could prove to be useful is when your entity goes through a life cycle where each state has very different behavior or behavior needs to be limited as of a certain stage in its life cycle. Of course, this shouldn't be used as an excuse to NOT model things explicitly.

### Conclusion

The most important takeaway is that a stream of events does not need to be loaded into the same class all the time and that roles remain useful within a model backed by event sourcing. Like anything, this should be used with moderation and only if applicable. (\*) I'm reliving a scene with Arnold in Total Recall (1990) as I'm writing this (http://www.youtube.com/watch?feature=player\_detailpage&v=WFMLGEHdIjE\#t=86s). (\*\*) Having worked in the Realtor business, I can tell you right off the bat that having a class per real estate property type is going to hurt in the long run, but who am I to judge about the usefulness of this particular model. (\*\*\*) Don't complain if the code doesn't compile out of the box. I used my C\# brain compiler.
